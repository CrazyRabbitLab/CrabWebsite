@page

<h1>基础数据类型 BasicDataType</h1>

@* ------------------------------------------------------------------------ *@

<ul>
    <li><a href="#布尔类型">布尔类型</a></li>
    <li><a href="#字符类型">字符类型</a></li>
    <li><a href="#整数类型">整数类型</a></li>
    <li><a href="#浮点数类型">浮点数类型</a></li>
</ul>

@* ------------------------------------------------------------------------ *@

<p>基础数据类型指的是计算机编程语言标准库中最为基础的数据类型, 是构成其他数据类型的基础.</p>
<p>有时各种数据类型共享有相似的数据与操作, 下面使用<code>Type</code>指代多种不同的数据类型.</p>
<p>需要注意: 在不同的语境中, <code>Type</code>指代的数据类型的种类是不同的.</p>
<p>再次强调: 在不同的语境中, <code>Type</code>指代的数据类型的种类是不同的.</p>

@* ------------------------------------------------------------------------ *@

<h2 id="布尔类型">布尔类型</h2>
<p>布尔类型就是真值与假值.</p>
<p>在Dotnet中, 布尔类型指的是: <code>System.Boolean</code>, 简写为bool.</p>
<p>System.Boolean的类型(Type)是结构体(struct).</p>

<p>静态数据</p>
<ul>
    <li>String Boolean.FalseStringbr</li>
    <li>String Boolean.TureStringbr</li>
</ul>
<p>静态操作</p>
<ul>
    <li>Boolean Boolean.Parse(String value)</li>
    <li>Boolean Boolean.Parse(ReadOnlySpan&lt;char&gt; value)</li>
    <li>Boolean Boolean.TryParse(String? value, out Boolean result)</li>
    <li>Boolean Boolean.TryParse(ReadOnlySpan&lt;char&gt; value, out Boolean result)</li>
</ul>
<p>实例数据</p>
<p>实例操作</p>
<ul>
    <li>Int32 BooleanInstance.CompareTo(Boolean value)</li>
    <li>Int32 BooleanInstance.CompareTo(Object? obj)</li>
    <li>Boolean BooleanInstance.Equals(Boolean obj)</li>
    <li>Boolean BooleanInstance.Equals(Object? obj)</li>
    <li>Int32 BooleanInstance.GetHashCode()</li>
    <li>TypeCode BooleanInstance.GetTypeCode()</li>
    <li>String BooleanInstance.ToString()</li>
    <li>String BooleanInstance.ToString(IFormatProvider? provider)</li>
    <li>Boolean BooleanInstance.TryFormat(Span&lt;char&gt; destination, out Int32 charsWritten)</li>
</ul>

@* ------------------------------------------------------------------------ *@

<h2 id="字符类型">字符类型</h2>

<p>字符类型就是单一字符, 在Dotnet中指的是UTF-16字符集中的某一个字符.</p>
<p>在Dotnet中字符类型指的是<code>System.Char</code></p>

<ul>
    <li>静态数据</li>
    <ul>
        <li>Char Char.MaxValue</li>
        <li>Char Char.MinValue</li>
    </ul>
    <li>静态操作</li>
    <ul>
        <li>String Char.ConvertFromUtf32(Int32 utf32)</li>
        <li>Int32 Char.ConvertToUtf32(Char highSurrogate, Char lowSurrogate)</li>
        <li>Int32 Char.ConvertToUtf32(String s, Int32 index)</li>
        <li>Double Char.GetNumericValue(Char c)</li>
        <li>Double Char.GetNumericValue(String s, Int32 index)</li>
        <li>UnicodeCategory Char.GetUnicodeCategory(Char c)</li>
        <li>UnicodeCategory Char.GetUnicodeCategory(String s, Int32 index)</li>
        <li>Boolean Char.IsAscii(Char c)</li>
        <li>Boolean Char.IsAsciiDigit(Char c)</li>
        <li>Boolean Char.IsAsciiHexDigit(Char c)</li>
        <li>Boolean Char.IsAsciiHexDigitLower(Char c)</li>
        <li>Boolean Char.IsAsciiHexDigitUpper(Char c)</li>
        <li>Boolean Char.IsAsciiLetter(Char c)</li>
        <li>Boolean Char.IsAsciiLetterLower(Char c)</li>
        <li>Boolean Char.IsAsciiLetterOrDigit(Char c)</li>
        <li>Boolean Char.IsAsciiLetterUpper(Char c)</li>
        <li>Boolean Char.IsBetween(Char c, Char minInclusive, Char maxInclusive)</li>
        <li>Boolean Char.IsControl(Char c)</li>
        <li>Boolean Char.IsControl(String s, Int32 index)</li>
        <li>Boolean Char.IsDigit(Char c)</li>
        <li>Boolean Char.IsDigit(String s, Int32 index)</li>
        <li>Boolean Char.IsHighSurrogate(Char c)</li>
        <li>Boolean Char.IsHighSurrogate(String s, Int32 index)</li>
        <li>Boolean Char.IsLetter(Char c)</li>
        <li>Boolean Char.IsLetter(String s, Int32 index)</li>
        <li>Boolean Char.IsLetterOrDigit(Char c)</li>
        <li>Boolean Char.IsLetterOrDigit(String s, Int32 index)</li>
        <li>Boolean Char.IsLower(Char c)</li>
        <li>Boolean Char.IsLower(String s, Int32 index)</li>
        <li>Boolean Char.IsLowSurrogate(Char c)</li>
        <li>Boolean Char.IsLowSurrogate(String s, Int32 index)</li>
        <li>Boolean Char.IsNumber(Char c)</li>
        <li>Boolean Char.IsNumber(String s, Int32 index)</li>
        <li>Boolean Char.IsPunctuation(Char c)</li>
        <li>Boolean Char.IsPunctuation(String s, Int32 index)</li>
        <li>Boolean Char.IsSeparator(Char c)</li>
        <li>Boolean Char.IsSeparator(String s, Int32 index)	</li>
        <li>Boolean Char.IsSurrogate(Char c)</li>
        <li>Boolean Char.IsSurrogate(String s, Int32 index)</li>
        <li>Boolean Char.IsSurrogatePair(Char highSurrogate, Char lowSurrogate)</li>
        <li>Boolean Char.IsSurrogatePair(String s, Int32 index)</li>
        <li>Boolean Char.IsSymbol(Char c)</li>
        <li>Boolean Char.IsSymbol(String s, Int32 index)</li>
        <li>Boolean Char.IsUpper(Char c)</li>
        <li>Boolean Char.IsUpper(String s, Int32 index)</li>
        <li>Boolean Char.IsWhiteSpace(Char c)</li>
        <li>Boolean Char.IsWhiteSpace(String s, Int32 index)</li>
        <li>Char Char.Parse(String s)</li>
        <li>Char Char.ToLower(Char c, System.Globalization.CultureInfo culture)</li>
        <li>Char Char.ToLower(Char c)</li>
        <li>Char Char.ToLowerInvariant(Char c)</li>
        <li>String Char.ToString(Char c)</li>
        <li>Char Char.ToUpper(Char c, System.Globalization.CultureInfo culture)</li>
        <li>Char Char.ToUpper(Char c)</li>
        <li>Char Char.ToUpperInvariant(Char c)</li>
        <li>Boolean Char.TryParse(String? s, out Char result)</li>
    </ul>
    <li>实例数据</li>
    <li>实例操作</li>
    <ul>
        <li>Int32 CharInstance.CompareTo(Char value)</li>
        <li>Int32 CharInstance.CompareTo(Object? value)</li>
        <li>Boolean CharInstance.Equals(Char obj)</li>
        <li>Boolean CharInstance.Equals(Object? obj)</li>
        <li>Int32 CharInstance.GetHashCode()</li>
        <li>TypeCode CharInstance.GetTypeCode()</li>
        <li>String CharInstance.ToString()</li>
        <li>String CharInstance.ToString(IFormatProvider? provider)</li>
    </ul>
</ul>

@* ------------------------------------------------------------------------ *@

<h2 id="整数类型">整数类型</h2>
<p>整数类型指的就是计算机中的正整数, 0 以及负整数.</p>
<p>在Dotnet中, 共有以下几种整数类型: <code>System.SByte</code> <code>System.Int16</code> <code>System.Int32</code> <code>System.Int64</code> <code>System.Int128</code> <code>System.Byte</code> <code>System.UInt16</code> <code>System.UInt32</code> <code>System.UInt64</code> <code>System.UInt128</code> </p>
<p>上述几种整数类型的核心区别是能够表达的数值范围不同.</p>
<p>上述整数类型的类型(Type)均为结构体(Struct).</p>
<p>因为整数类型之间有着大量相似的数据与操作, 下述以Type和TypeInstance代替具体类型. 请一定要注意具体数据 操作中Type与TypeInstance到底指代的是什么.</p>

<ul>
    <li>静态数据: </li>
    <ul>
        <li>下述静态数据中, Type指的是: SByte Int16 Int32 Int64 Int128 Byte UInt16 Uint32 Uint64 Uint128</li>
        <ul>
            <li>Type.MaxValue</li>
            <li>Type.MinValue</li>
        </ul>
        <li>下述静态数据中, Type指的是: Int128 UInt128</li>
        <ul>
            <li>Type.Zore</li>
            <li>Type.One</li>
        </ul>
        <li>下述静态数据中, Type指的是: Int128</li>
        <ul>
            <li>Int128.NegativeOne</li>
        </ul>
    </ul>
    <li>静态操作: </li>
    <ul>
        <li>下述静态操作中, Type指的是: SByte Int16 Int32 Int64 Int128 Byte UInt16 Uint32 Uint64 Uint128</li>
        <ul>
            <li>Type.Clamp(Type, Type, Type)</li>
            <li>Type.CreateChecked&lt;TOther&gt;(TOther)</li>
            <li>Type.CreateSaturating&lt;TOther&gt;(TOther)</li>
            <li>Type.CreateTruncating&lt;TOther&gt;(TOther)</li>
            <li>Type.DivRem(Type, Type)</li>
            <li>Type.IsEvenInteger(Type)</li>
            <li>Type.IsOddInteger(Type)</li>
            <li>Type.IsPow2(Type)</li>
            <li>Type.LeadingZeroCount(Type)</li>
            <li>Type.Log2(Type)</li>
            <li>Type.Max(Type, Type)</li>
            <li>Type.Min(Type, Type)</li>
            <li>Type.Parse(ReadOnlySpan&lt;Byte&gt;, IFormatProvider)</li>
            <li>Type.Parse(ReadOnlySpan&lt;Byte&gt;, NumberStyles, IFormatProvider)</li>
            <li>Type.Parse(ReadOnlySpan&lt;Char&gt;, IFormatProvider)</li>
            <li>Type.Parse(ReadOnlySpan&lt;Char&gt;, NumberStyles, IFormatProvider)</li>
            <li>Type.Parse(String, IFormatProvider)</li>
            <li>Type.Parse(String, NumberStyles, IFormatProvider)</li>
            <li>Type.Parse(String, NumberStyles)</li>
            <li>Type.Parse(String)</li>
            <li>Type.PopCount(SByte)</li>
            <li>Type.RotateLeft(Type, Int32)</li>
            <li>Type.RotateRight(Type, Int32)</li>
            <li>Type.Sign(Type)</li>
            <li>Type.TrailingZeroCount(Type)</li>
            <li>Type.TryParse(ReadOnlySpan&lt;Byte&gt;, IFormatProvider, Type)</li>
            <li>Type.TryParse(ReadOnlySpan&lt;Byte&gt;, NumberStyles, IFormatProvider, Type)</li>
            <li>Type.TryParse(ReadOnlySpan&lt;Byte&gt;, Type)</li>
            <li>Type.TryParse(ReadOnlySpan&lt;Char&gt;, IFormatProvider, Type)</li>
            <li>Type.TryParse(ReadOnlySpan&lt;Char&gt;, NumberStyles, IFormatProvider, Type)</li>
            <li>Type.TryParse(ReadOnlySpan&lt;Char&gt;, Type)</li>
            <li>Type.TryParse(String, IFormatProvider, Type)</li>
            <li>Type.TryParse(String, Type)</li>
            <li>Type.TryParse(String, NumberStyles, IFormatProvider, Type)</li>
        </ul>
        <li>下述静态操作中, Type指的是: SByte Int16 Int32 Int64 Int128</li>
        <ul>
            <li>Type.Abs(Type)</li>
            <li>Type.IsNegative(Type)</li>
            <li>Type.IsPositive(Type)</li>
            <li>Type.CopySign(Type, Type)</li>
            <li>Type.MaxMagnitude(Type, Type)</li>
            <li>Type.MinMagnitude(Type, Type)</li>
        </ul>
        <li>下述静态操作中, Type指的是: Int32 Int64 Int128 Uint32 Uint64 Uint128 </li>
        <ul>
            <li>Type.BigMul(Type, Type)</li>
        </ul>
    </ul>
    <li>实例数据: </li>
    <ul>
        <li>所有的整数类型均没有实例数据.</li>
    </ul>
    <li>实例操作: </li>
    <ul>
        <li>下述实例操作中, Type指的是: SByte Int16 Int32 Int64 Int128 Byte UInt16 Uint32 Uint64 Uint128</li>
        <ul>
            <li>CompareTo(Type)</li>
            <li>CompareTo(Object)</li>
            <li>Equals(Type)</li>
            <li>Equals(Object)</li>
            <li>GetHashCode()</li>
            <li>ToString()</li>
            <li>ToString(IFormatProvider)</li>
            <li>ToString(String, IFormatProvider)</li>
            <li>ToString(String)</li>
            <li>TryFormat(Span&lt;Byte&gt;, Int32, ReadOnlySpan&lt;Char&gt;, IFormatProvider)</li>
            <li>TryFormat(Span&lt;Char&gt;, Int32, ReadOnlySpan&lt;Char&gt;, IFormatProvider)</li>
        </ul>
        <li>下述实例操作中, Type指的是: SByte Int16 Int32 Int64 Byte UInt16 Uint32 Uint64</li>
        <ul>
            <li>Type.GetTypeCode()</li>
        </ul>
    </ul>
</ul>





@* ------------------------------------------------------------------------ *@

<h2 id="浮点数类型">浮点数类型</h2>
<p>浮点数类型指的就是数学中的带有小数点的小数类型.</p>
<p>在Dotnet中, 共有以下几种浮点数类型: <code>System.Half</code> <code>System.Single</code> <code>System.Double</code> <code>System.Decimal</code></p>
<p>其中, <code>System.Half</code> <code>System.Single</code> <code>System.Double</code>是二进制浮点数; <code>System.Decimal</code>是十进制浮点数.</p>

<ul>
    <li>静态数据: </li>
    <ul>
        <li></li>
    </ul>
    <li>静态操作: </li>
    <li>实例数据: </li>
    <li>实例操作: </li>
</ul>







































@* 
<h3>详细说明</h3>
<p>静态数据</p>
<ul>
    <li>String Boolean.FalseStringbr <br> <small>和字符串"False"等价</small></li>
    <li>String Boolean.TureStringbr <br> <small>和字符串"True"等价</small></li>
</ul>

<p>静态操作</p>
<ul>
    <li>Boolean Boolean.Parse(String value) <br> <small>将传入的字符串value转换成布尔类型输出</small></li>
    <li>Boolean Boolean.TryParse(String value) <br><small>将传入的字符串value转换成布尔类型输出</small></li>
</ul>
<p>Boolean.Parse()与Boolean.TryParse()的本质区别是异常处理不同: </p>
<p>相同之处: 当传入的字符串value与"True"相等时, 输出Ture; 当传入的字符串value与"False"相等时, 传出False.</p>
<p>不同之处: 当传入的字符串value是Null时, Boolean.Parse()会输出异常ArgumentNullException; 而Boolean.TryParse()会输出False.</p>
<p>当传入的字符串value既不是"True" "False"又不是Null时, Boolean.Parse()会抛出异常FormatException; 而Boolean.TryParse()会输出False.</p>
<p>需要注意的是, 上述的Boolean.Parse()与Boolean.TryBoolean()均是大小写敏感的.</p>

<p>实例数据</p>
<ul>
    <li>无实例数据</li>
</ul>

<p>实例操作</p>
<ul>
    <li>Int32 Instance.CompareTo(Boolean value) <br><small>当这个实例本身与传入的布尔类型参数value相等时, 返回值是Int32类型的0; 当这个实例本身是False而传入的布尔类型参数value是True时, 返回值是</small> </li>
    <li>Boolean Instance.Equals(Boolean obj)</li>
    <li>Int32 Instance.GetHashCode()</li>
    <li>TypeCode Instance.GetTypeCode()</li>
    <li>String Instance.ToString()</li>
</ul>
<p></p>

    <li>实例数据</li>
    <li>实例操作</li>
    <ul>
        <li>Int32 Instance.CompareTo(Boolean value)</li>
        <ul>
            <li>介绍: 将这个实例本身与特定的布尔对象进行比较, 然后返回一个表明它们之间关系的整数.</li>
            <li>输入: </li>
            <ul>
                <li>value: 一个将用来与这个实例进行比较的布尔对象.</li>
            </ul>
            <li>输出: </li>
            <ul>
                <li>输出一个代表这个示例与value之间关系的Int32, 其中: </li>
                <li>当两者都是<code>True</code>或两者都是<code>False</code>时, 返回值是0</li>
                <li>当实例是<code>False</code>并且value是<code>True</code>时, 返回值小于0</li>
                <li>当实例是<code>True</code>并且value是<code>False</code>时, 返回值大于0</li>
            </ul>

        </ul>
        <li>Int32 Instance.CompareTo(Object? obj)</li>
        <ul>
            <li>介绍: 将这个实例与特定的对象进行比较, 然后返回一个表明它们之间关系的整数.</li>
            <li>输入: </li>
            <ul>
                <li>obj: 一个将用来与这个实例进行比较的对象, 或者是<code>null</code></li>
            </ul>
            <li>输出: </li>
            <ul>
                <li>输出一个代表这个实例与obj之间关系的Int32, 其中: </li>
                <li>当两者都是<code>True</code>或两者都是<code>False</code>时, 返回值是0</li>
                <li>当实例是<code>False</code>并且obj是<code>True</code>时, 返回值小于0</li>
                <li>当实例是<code>True</code>并且obj是<code>False</code>时,或者obj是<code>null</code>时, 返回值大于0</li>
            </ul>
            <li>注意: </li>
            <ul>
                <li>obj必须是<code>null</code>或者Boolean的一个实例, 其他情况下会抛出异常ArgumentException</li>
            </ul>
        </ul>
        <li>Boolean Instance.Equals(Boolean obj)</li>
        <ul>
            <li>介绍: 返回一个布尔值, 这个布尔值代表了这个实例是否和特定的布尔对象相等.</li>
            <li>输入: </li>
            <ul>
                <li>obj: 一个要去和这个实例进行比较的布尔值</li>
            </ul>
            <li>输出: </li>
            <ul>
                <li>输出一个布尔值, 其中: </li>
                <li>当输入的obj和这个实例具有相同的值的时候, 返回<code>True</code></li>
                <li>其他情况下, 返回<code>False</code></li>
            </ul>
        </ul>
        <li>Boolean Instance.Equals(Object? obj)</li>
        <ul>
            <li>介绍: 返回一个布尔值, 这个布尔值代表了这个实例是否和特定的对象相等.</li>
            <li>输入: </li>
            <ul>
                <li>obj: 一个要去和这个实例进行比较的对象.</li>
            </ul>
            <li>输出: </li>
            <ul>
                <li>输出一个布尔值, 其中: </li>
                <li>当输入的obj和这个实例具有相同的值的时候, 返回<code>True</code></li>
                <li>其他情况下, 返回<code>False</code></li>
            </ul>
        </ul>
        <li>Int32 Instance.GetHashCode()</li>
        <ul>
            <li>介绍: 返回这个实例的哈希值</li>
            <li>输入: 无需输入</li>
            <li>输出: </li>
            <ul>
                <li>输出一个代表当前实例的Int32哈希值</li>
            </ul>
        </ul>
        <li>TypeCode Instance.GetTypeCode()</li>
        <ul>
            <li>介绍: 获取当前实例的类型代码TypeCode</li>
            <li>输入: 无需输入</li>
            <li>输出: </li>
            <ul>
                <li>返回一个Bollean枚举常量.</li>
            </ul>
        </ul>
        <li>String Instance.ToString()</li>
        <ul>
            <li>介绍: 将这个实例转换成相等的字符串.</li>
            <li>输入: 无需输入</li>
            <li>输出: </li>
            <ul>
                <li>输出一个字符串, 这个字符串的值和这个布尔实例的值相等, 也就是: </li>
                <li>当这个布尔实例的值等于<code>True</code>时, 返回<code>Boolean.TrueString</code> </li>
                <li>当这个布尔实例的值等于<code>False</code>时, 返回<code>Boolean.FalseString</code> </li>
            </ul>
            <li>注意: </li>
            <ul>
                <li>这个方法返回的是字符串常量"False"或者字符串常量"True".</li>
                <li>在xml中, xml是大小写敏感的, 并且默认"false"以及"true"才是有效的, 所以如果需要将值写入到xml中时, 要使用<code>StringInstance.ToLowerInvariant()</code>, 将其转换成小写形式再写入xml文件. </li>
            </ul>
        </ul>
        <li>String Instance.ToString(IFormatProvider? provider)</li>
        <li>Boolean Instance.TryFormat(Span&lt;char&gt; destination, out Int32 charsWritten)</li>
    </ul>
</ul> *@